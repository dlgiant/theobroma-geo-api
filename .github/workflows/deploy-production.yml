name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  AWS_REGION: us-east-2
  ECR_REPOSITORY: theobroma-geo-api
  ECS_SERVICE: theobroma-geo-api-service
  ECS_CLUSTER: theobroma-production
  ECS_TASK_DEFINITION: theobroma-geo-api-task
  CONTAINER_NAME: theobroma-geo-api

jobs:
  build-and-push:
    name: Build and Push to ECR
    runs-on: ubuntu-latest
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      image-tag: ${{ steps.image-tag.outputs.tag }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Generate image tag
      id: image-tag
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          # Use tag name for tagged releases
          TAG=${GITHUB_REF#refs/tags/}
        else
          # Use branch name and short SHA for branch pushes
          TAG="${GITHUB_REF_NAME}-$(echo $GITHUB_SHA | cut -c1-8)"
        fi
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Using image tag: $TAG"
        
    - name: Debug AWS secrets availability
      run: |
        echo "Checking AWS secrets availability..."
        echo "AWS_ACCESS_KEY_ID exists: ${{ secrets.AWS_ACCESS_KEY_ID != '' }}"
        echo "AWS_SECRET_ACCESS_KEY exists: ${{ secrets.AWS_SECRET_ACCESS_KEY != '' }}"
        echo "AWS_ACCOUNT_ID exists: ${{ secrets.AWS_ACCOUNT_ID != '' }}"
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        mask-aws-account-id: false
        
    - name: Verify AWS credentials
      run: |
        echo "üîç Verifying AWS credentials and permissions..."
        aws sts get-caller-identity
        echo "‚úÖ AWS credentials verified"
        
    - name: Create ECR repository if not exists
      run: |
        echo "üèóÔ∏è Ensuring ECR repository exists..."
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY 2>/dev/null || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        echo "‚úÖ ECR repository ready: $ECR_REPOSITORY"
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Build and push image to ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
      run: |
        echo "üîç Build job debug info:"
        echo "ECR_REGISTRY: $ECR_REGISTRY"
        echo "ECR_REPOSITORY: $ECR_REPOSITORY"
        echo "IMAGE_TAG: $IMAGE_TAG"
        
        if [ -z "$ECR_REGISTRY" ]; then
          echo "‚ùå ECR_REGISTRY is empty!"
          exit 1
        fi
        
        if [ -z "$IMAGE_TAG" ]; then
          echo "‚ùå IMAGE_TAG is empty!"
          exit 1
        fi
        
        # Build image
        echo "üèóÔ∏è Building Docker images..."
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push image to ECR
        echo "üì§ Pushing images to ECR..."
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Set output with full image URI
        IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        echo "image=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "‚úÖ Image pushed to ECR: $IMAGE_URI"
        echo "üìù Output set: image=$IMAGE_URI"
        
    - name: Scan image for vulnerabilities
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.build-image.outputs.image }}
        format: 'sarif'
        output: 'trivy-results.sarif'
      continue-on-error: true
      
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
      continue-on-error: true

  deploy-production:
    name: Deploy to Production ECS
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    
    environment:
      name: production
      url: https://api.theobroma.digital
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Verify ECS infrastructure
      run: |
        echo "üîç Verifying ECS infrastructure..."
        
        # Check if ECS cluster exists
        if ! aws ecs describe-clusters --clusters ${{ env.ECS_CLUSTER }} --query 'clusters[0].status' --output text 2>/dev/null | grep -q ACTIVE; then
          echo "‚ùå ECS cluster ${{ env.ECS_CLUSTER }} not found or not active"
          echo "Please create the ECS cluster first:"
          echo "aws ecs create-cluster --cluster-name ${{ env.ECS_CLUSTER }}"
          exit 1
        fi
        echo "‚úÖ ECS cluster verified: ${{ env.ECS_CLUSTER }}"
        
        # Check if ECS service exists
        if ! aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --query 'services[0].status' --output text 2>/dev/null | grep -q ACTIVE; then
          echo "‚ö†Ô∏è ECS service ${{ env.ECS_SERVICE }} not found - will create initial task definition"
          echo "CREATE_SERVICE=true" >> $GITHUB_ENV
        else
          echo "‚úÖ ECS service verified: ${{ env.ECS_SERVICE }}"
          echo "CREATE_SERVICE=false" >> $GITHUB_ENV
        fi
        
    - name: Create IAM roles for ECS
      run: |
        echo "üîç Creating IAM roles for ECS..."
        
        # Create ECS Task Execution Role
        if ! aws iam get-role --role-name ecsTaskExecutionRole >/dev/null 2>&1; then
          echo "Creating ecsTaskExecutionRole..."
          
          # Create trust policy
          cat > trust-policy.json << EOF
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": "ecs-tasks.amazonaws.com"
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
        EOF
          
          aws iam create-role \
            --role-name ecsTaskExecutionRole \
            --assume-role-policy-document file://trust-policy.json
            
          aws iam attach-role-policy \
            --role-name ecsTaskExecutionRole \
            --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
            
          echo "‚úÖ ecsTaskExecutionRole created"
        else
          echo "‚úÖ ecsTaskExecutionRole already exists"
        fi
        
        # Create ECS Task Role
        if ! aws iam get-role --role-name ecsTaskRole >/dev/null 2>&1; then
          echo "Creating ecsTaskRole..."
          
          aws iam create-role \
            --role-name ecsTaskRole \
            --assume-role-policy-document file://trust-policy.json
            
          # Create basic task policy for application permissions
          cat > task-policy.json << EOF
        {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Action": [
                "logs:CreateLogStream",
                "logs:PutLogEvents"
              ],
              "Resource": "*"
            }
          ]
        }
        EOF
          
          aws iam put-role-policy \
            --role-name ecsTaskRole \
            --policy-name ECSTaskPolicy \
            --policy-document file://task-policy.json
            
          echo "‚úÖ ecsTaskRole created"
        else
          echo "‚úÖ ecsTaskRole already exists"
        fi
        
    - name: Create CloudWatch log group
      run: |
        echo "üîç Creating CloudWatch log group..."
        aws logs create-log-group --log-group-name "/ecs/${{ env.ECS_TASK_DEFINITION }}" 2>/dev/null || echo "Log group already exists"
        echo "‚úÖ CloudWatch log group ready"
        
    - name: Create initial task definition
      if: env.CREATE_SERVICE == 'true'
      run: |
        echo "üèóÔ∏è Creating initial task definition..."
        cat > task-definition.json << EOF
        {
          "family": "${{ env.ECS_TASK_DEFINITION }}",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "512",
          "memory": "1024",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskRole",
          "containerDefinitions": [
            {
              "name": "${{ env.CONTAINER_NAME }}",
              "image": "placeholder-image",
              "portMappings": [
                {
                  "containerPort": 8000,
                  "protocol": "tcp"
                }
              ],
              "essential": true,
              "environment": [
                {
                  "name": "ENVIRONMENT",
                  "value": "production"
                },
                {
                  "name": "LOG_LEVEL",
                  "value": "INFO"
                },
                {
                  "name": "DATABASE_URL",
                  "value": "${{ secrets.PRODUCTION_DATABASE_URL }}"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ env.ECS_TASK_DEFINITION }}",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"],
                "interval": 30,
                "timeout": 5,
                "retries": 3,
                "startPeriod": 60
              }
            }
          ]
        }
        EOF
        echo "‚úÖ Initial task definition created"
        
    - name: Download current task definition
      if: env.CREATE_SERVICE == 'false'
      run: |
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_TASK_DEFINITION }} \
          --query taskDefinition > raw-task-definition.json
          
        # Clean the task definition by removing AWS-added fields
        jq 'del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)' \
           raw-task-definition.json > task-definition.json
           
        echo "‚úÖ Current task definition downloaded and cleaned"
        
    - name: Debug and update task definition with new image
      run: |
        echo "üîç Debugging task definition and image info..."
        echo "Build job result: ${{ needs.build-and-push.result }}"
        echo "Build job outputs available:"
        echo "  image-uri: '${{ needs.build-and-push.outputs.image-uri }}'"
        echo "  image-tag: '${{ needs.build-and-push.outputs.image-tag }}'"
        
        IMAGE_URI="${{ needs.build-and-push.outputs.image-uri }}"
        IMAGE_TAG="${{ needs.build-and-push.outputs.image-tag }}"
        
        echo "Image URI: '$IMAGE_URI'"
        echo "Image TAG: '$IMAGE_TAG'"
        echo "Container name: ${{ env.CONTAINER_NAME }}"
        echo "Task definition file exists: $(test -f task-definition.json && echo 'YES' || echo 'NO')"
        
        # Check if build job failed
        if [ "${{ needs.build-and-push.result }}" != "success" ]; then
          echo "‚ùå Build job failed with status: ${{ needs.build-and-push.result }}"
          exit 1
        fi
        
        # Try to construct image URI if empty
        if [ -z "$IMAGE_URI" ]; then
          echo "‚ö†Ô∏è Image URI is empty, attempting to construct it..."
          
          # Get AWS account ID
          AWS_ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          if [ -n "$AWS_ACCOUNT_ID" ] && [ -n "$IMAGE_TAG" ]; then
            CONSTRUCTED_IMAGE_URI="$AWS_ACCOUNT_ID.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:$IMAGE_TAG"
            echo "Constructed Image URI: $CONSTRUCTED_IMAGE_URI"
            
            # Verify the image exists in ECR
            if aws ecr describe-images --repository-name ${{ env.ECR_REPOSITORY }} --image-ids imageTag=$IMAGE_TAG > /dev/null 2>&1; then
              IMAGE_URI="$CONSTRUCTED_IMAGE_URI"
              echo "‚úÖ Using constructed image URI: $IMAGE_URI"
            else
              echo "‚ùå Constructed image does not exist in ECR"
              exit 1
            fi
          else
            echo "‚ùå Cannot construct image URI - missing AWS account ID or image tag"
            echo "AWS_ACCOUNT_ID: $AWS_ACCOUNT_ID"
            echo "IMAGE_TAG: $IMAGE_TAG"
            exit 1
          fi
        fi
        
        if [ ! -f task-definition.json ]; then
          echo "‚ùå Error: task-definition.json file not found!"
          exit 1
        fi
        
        echo "‚úÖ Updating task definition with image: $IMAGE_URI"
        
        # Use jq to update the task definition with the new image
        jq --arg IMAGE "$IMAGE_URI" \
           '.containerDefinitions[0].image = $IMAGE' \
           task-definition.json > updated-task-definition.json
           
        # Also update environment variables
        jq '.containerDefinitions[0].environment += [
             {"name": "ENVIRONMENT", "value": "production"},
             {"name": "LOG_LEVEL", "value": "INFO"},
             {"name": "AWS_REGION", "value": "${{ env.AWS_REGION }}"}
           ]' updated-task-definition.json > final-task-definition.json
        
        mv final-task-definition.json task-definition.json
        
        echo "‚úÖ Task definition updated successfully"
        echo "Updated task definition:"
        cat task-definition.json
          
    - name: Register task definition
      run: |
        echo "üìù Registering task definition..."
        aws ecs register-task-definition --cli-input-json file://task-definition.json
        echo "‚úÖ Task definition registered"
        
    - name: Create ECS service (if needed)
      if: env.CREATE_SERVICE == 'true'
      run: |
        echo "üèóÔ∏è Creating ECS service..."
        
        # Get VPC and subnet info (assuming default VPC for now)
        VPC_ID=$(aws ec2 describe-vpcs --filters "Name=is-default,Values=true" --query 'Vpcs[0].VpcId' --output text)
        SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[*].SubnetId' --output text | tr '\t' ',')
        
        echo "Using VPC: $VPC_ID"
        echo "Using Subnets: $SUBNET_IDS"
        
        # Create security group if it doesn't exist
        SG_ID=$(aws ec2 describe-security-groups --filters "Name=group-name,Values=theobroma-api-sg" --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || echo "None")
        
        if [ "$SG_ID" = "None" ]; then
          echo "Creating security group..."
          SG_ID=$(aws ec2 create-security-group \
            --group-name theobroma-api-sg \
            --description "Security group for Theobroma API" \
            --vpc-id $VPC_ID \
            --query 'GroupId' --output text)
            
          # Allow HTTP traffic
          aws ec2 authorize-security-group-ingress \
            --group-id $SG_ID \
            --protocol tcp \
            --port 8000 \
            --cidr 0.0.0.0/0
            
          echo "‚úÖ Security group created: $SG_ID"
        else
          echo "‚úÖ Using existing security group: $SG_ID"
        fi
        
        # Create the ECS service
        aws ecs create-service \
          --cluster ${{ env.ECS_CLUSTER }} \
          --service-name ${{ env.ECS_SERVICE }} \
          --task-definition ${{ env.ECS_TASK_DEFINITION }} \
          --desired-count 1 \
          --launch-type FARGATE \
          --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SG_ID],assignPublicIp=ENABLED}"
          
        echo "‚úÖ ECS service created: ${{ env.ECS_SERVICE }}"
        
    - name: Update existing ECS service (if exists)
      if: env.CREATE_SERVICE == 'false'
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: task-definition.json
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true
        
    - name: Wait for deployment to stabilize
      run: |
        echo "‚è≥ Waiting for service to reach steady state..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }}
        echo "‚úÖ Service deployment completed successfully"
        
    - name: Get service details
      run: |
        # Get the load balancer URL
        LOAD_BALANCER_DNS=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].loadBalancers[0].targetGroupArn' \
          --output text | xargs -I {} aws elbv2 describe-target-groups \
          --target-group-arns {} \
          --query 'TargetGroups[0].LoadBalancerArns[0]' \
          --output text | xargs -I {} aws elbv2 describe-load-balancers \
          --load-balancer-arns {} \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
          
        echo "üåê Application URL: https://$LOAD_BALANCER_DNS"
        echo "üì¶ Deployed Image: ${{ needs.build-and-push.outputs.image-uri }}"
        echo "üè∑Ô∏è Image Tag: ${{ needs.build-and-push.outputs.image-tag }}"
        
    - name: Get service public IP and debug
      run: |
        echo "üîç Getting service details and debugging..."
        
        # Get task ARN
        TASK_ARN=$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_SERVICE }} --query 'taskArns[0]' --output text)
        echo "üìã Task ARN: $TASK_ARN"
        
        # Get task status
        TASK_STATUS=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $TASK_ARN --query 'tasks[0].lastStatus' --output text)
        echo "üìä Task Status: $TASK_STATUS"
        
        # Get task health status
        HEALTH_STATUS=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $TASK_ARN --query 'tasks[0].healthStatus' --output text)
        echo "üè• Health Status: $HEALTH_STATUS"
        
        # Get network interface and public IP
        ENI_ID=$(aws ecs describe-tasks --cluster ${{ env.ECS_CLUSTER }} --tasks $TASK_ARN --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text)
        echo "üåê Network Interface: $ENI_ID"
        
        PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --query 'NetworkInterfaces[0].Association.PublicIp' --output text)
        echo "üéØ Public IP: $PUBLIC_IP"
        
        # Check security group
        SG_ID=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --query 'NetworkInterfaces[0].Groups[0].GroupId' --output text)
        echo "üîí Security Group: $SG_ID"
        
        # List security group rules
        echo "üìã Security Group Rules:"
        aws ec2 describe-security-groups --group-ids $SG_ID --query 'SecurityGroups[0].IpPermissions' --output table
        
        # Set the health URL for next step
        echo "HEALTH_URL=http://$PUBLIC_IP:8000/health" >> $GITHUB_ENV
        
    - name: Check container logs
      run: |
        echo "üìã Checking container logs..."
        
        # Get the latest log events
        LOG_STREAM="ecs/${{ env.CONTAINER_NAME }}/$(aws ecs list-tasks --cluster ${{ env.ECS_CLUSTER }} --service-name ${{ env.ECS_SERVICE }} --query 'taskArns[0]' --output text | rev | cut -d'/' -f1 | rev)"
        echo "üìÑ Log Stream: $LOG_STREAM"
        
        # Get recent log events
        aws logs get-log-events \
          --log-group-name "/ecs/${{ env.ECS_TASK_DEFINITION }}" \
          --log-stream-name "$LOG_STREAM" \
          --limit 20 \
          --query 'events[*].message' \
          --output text || echo "‚ùå Could not retrieve logs"
        
    - name: Run health checks
      run: |
        echo "üîç Running post-deployment health checks..."
        echo "üéØ Testing endpoint: $HEALTH_URL"
        
        # Wait for application to be ready
        sleep 30
        
        # Retry health check up to 10 times
        for i in {1..10}; do
          echo "Attempt $i: Testing $HEALTH_URL"
          if curl -f -s --connect-timeout 10 --max-time 30 "$HEALTH_URL" > /dev/null; then
            echo "‚úÖ Health check passed (attempt $i)"
            echo "üìä Response:"
            curl -s "$HEALTH_URL" | jq . || curl -s "$HEALTH_URL"
            break
          else
            echo "‚è≥ Health check failed (attempt $i), retrying in 30s..."
            if [ $i -eq 10 ]; then
              echo "‚ùå Health check failed after 10 attempts"
              echo "üîç Testing basic connectivity:"
              curl -v --connect-timeout 5 "$HEALTH_URL" || true
              exit 1
            fi
            sleep 30
          fi
        done
        
    - name: Run smoke tests
      run: |
        echo "üß™ Running production smoke tests..."
        
        BASE_URL="https://api.theobroma.digital"
        
        # Test critical endpoints
        endpoints=(
          "/health"
          "/farms"
          "/docs"
        )
        
        for endpoint in "${endpoints[@]}"; do
          echo "Testing $BASE_URL$endpoint"
          if curl -f -s "$BASE_URL$endpoint" > /dev/null; then
            echo "‚úÖ $endpoint: PASSED"
          else
            echo "‚ùå $endpoint: FAILED"
            exit 1
          fi
        done
        
        echo "‚úÖ All smoke tests passed"
        
    - name: Update deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "## üöÄ Production Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üåê Production URL**: https://api.theobroma.digital" >> $GITHUB_STEP_SUMMARY
          echo "**üì¶ Image**: ${{ needs.build-and-push.outputs.image-uri }}" >> $GITHUB_STEP_SUMMARY
          echo "**üè∑Ô∏è Tag**: ${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**üïí Deployed**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Health Checks" >> $GITHUB_STEP_SUMMARY
          echo "- Health endpoint: PASSED" >> $GITHUB_STEP_SUMMARY
          echo "- Smoke tests: PASSED" >> $GITHUB_STEP_SUMMARY
          echo "- Service stability: PASSED" >> $GITHUB_STEP_SUMMARY
        else
          echo "## ‚ùå Production Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üì¶ Image**: ${{ needs.build-and-push.outputs.image-uri }}" >> $GITHUB_STEP_SUMMARY
          echo "**üïí Failed at**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please check the deployment logs and fix any issues before retrying." >> $GITHUB_STEP_SUMMARY
        fi

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-production]
    if: failure() && needs.deploy-production.result == 'failure'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Rollback to previous version
      run: |
        echo "üîÑ Initiating rollback to previous stable version..."
        
        # Get the previous task definition revision
        CURRENT_REVISION=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].taskDefinition' \
          --output text | grep -o '[0-9]*$')
          
        PREVIOUS_REVISION=$((CURRENT_REVISION - 1))
        
        if [ $PREVIOUS_REVISION -gt 0 ]; then
          echo "Rolling back from revision $CURRENT_REVISION to $PREVIOUS_REVISION"
          
          # Update service with previous task definition
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ env.ECS_TASK_DEFINITION }}:$PREVIOUS_REVISION
            
          # Wait for rollback to complete
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}
            
          echo "‚úÖ Rollback completed successfully"
        else
          echo "‚ùå No previous revision found for rollback"
          exit 1
        fi

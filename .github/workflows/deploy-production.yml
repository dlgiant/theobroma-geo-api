name: Deploy to Production

on:
  push:
    branches: [ main ]
    tags: [ 'v*' ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: theobroma-geo-api
  ECS_SERVICE: theobroma-geo-api-service
  ECS_CLUSTER: theobroma-production
  ECS_TASK_DEFINITION: theobroma-geo-api-task
  CONTAINER_NAME: theobroma-geo-api

jobs:
  build-and-push:
    name: Build and Push to ECR
    runs-on: ubuntu-latest
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      image-tag: ${{ steps.image-tag.outputs.tag }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Generate image tag
      id: image-tag
      run: |
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          # Use tag name for tagged releases
          TAG=${GITHUB_REF#refs/tags/}
        else
          # Use branch name and short SHA for branch pushes
          TAG="${GITHUB_REF_NAME}-$(echo $GITHUB_SHA | cut -c1-8)"
        fi
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Using image tag: $TAG"
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
        role-session-name: GitHub-Actions-Deploy
        mask-aws-account-id: false
        
    - name: Verify AWS credentials
      run: |
        echo "üîç Verifying AWS credentials and permissions..."
        aws sts get-caller-identity
        echo "‚úÖ AWS credentials verified"
        
    - name: Create ECR repository if not exists
      run: |
        echo "üèóÔ∏è Ensuring ECR repository exists..."
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY 2>/dev/null || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        echo "‚úÖ ECR repository ready: $ECR_REPOSITORY"
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Build and push image to ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ steps.image-tag.outputs.tag }}
      run: |
        # Build image
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push image to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "‚úÖ Image pushed to ECR: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        
    - name: Scan image for vulnerabilities
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.build-image.outputs.image }}
        format: 'sarif'
        output: 'trivy-results.sarif'
      continue-on-error: true
      
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      with:
        sarif_file: 'trivy-results.sarif'
      continue-on-error: true

  deploy-production:
    name: Deploy to Production ECS
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    
    environment:
      name: production
      url: https://api.theobroma.digital
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Verify ECS infrastructure
      run: |
        echo "üîç Verifying ECS infrastructure..."
        
        # Check if ECS cluster exists
        if ! aws ecs describe-clusters --clusters ${{ env.ECS_CLUSTER }} --query 'clusters[0].status' --output text 2>/dev/null | grep -q ACTIVE; then
          echo "‚ùå ECS cluster ${{ env.ECS_CLUSTER }} not found or not active"
          echo "Please create the ECS cluster first:"
          echo "aws ecs create-cluster --cluster-name ${{ env.ECS_CLUSTER }}"
          exit 1
        fi
        echo "‚úÖ ECS cluster verified: ${{ env.ECS_CLUSTER }}"
        
        # Check if ECS service exists
        if ! aws ecs describe-services --cluster ${{ env.ECS_CLUSTER }} --services ${{ env.ECS_SERVICE }} --query 'services[0].status' --output text 2>/dev/null | grep -q ACTIVE; then
          echo "‚ö†Ô∏è ECS service ${{ env.ECS_SERVICE }} not found - will create initial task definition"
          echo "CREATE_SERVICE=true" >> $GITHUB_ENV
        else
          echo "‚úÖ ECS service verified: ${{ env.ECS_SERVICE }}"
          echo "CREATE_SERVICE=false" >> $GITHUB_ENV
        fi
        
    - name: Create initial task definition
      if: env.CREATE_SERVICE == 'true'
      run: |
        echo "üèóÔ∏è Creating initial task definition..."
        cat > task-definition.json << EOF
        {
          "family": "${{ env.ECS_TASK_DEFINITION }}",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "512",
          "memory": "1024",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "taskRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskRole",
          "containerDefinitions": [
            {
              "name": "${{ env.CONTAINER_NAME }}",
              "image": "${{ needs.build-and-push.outputs.image-uri }}",
              "portMappings": [
                {
                  "containerPort": 8000,
                  "protocol": "tcp"
                }
              ],
              "essential": true,
              "environment": [
                {
                  "name": "ENVIRONMENT",
                  "value": "production"
                },
                {
                  "name": "LOG_LEVEL",
                  "value": "INFO"
                },
                {
                  "name": "DATABASE_URL",
                  "value": "${{ secrets.PRODUCTION_DATABASE_URL }}"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/${{ env.ECS_TASK_DEFINITION }}",
                  "awslogs-region": "${{ env.AWS_REGION }}",
                  "awslogs-stream-prefix": "ecs"
                }
              },
              "healthCheck": {
                "command": ["CMD-SHELL", "curl -f http://localhost:8000/health || exit 1"],
                "interval": 30,
                "timeout": 5,
                "retries": 3,
                "startPeriod": 60
              }
            }
          ]
        }
        EOF
        echo "‚úÖ Initial task definition created"
        
    - name: Download current task definition
      run: |
        aws ecs describe-task-definition \
          --task-definition ${{ env.ECS_TASK_DEFINITION }} \
          --query taskDefinition > task-definition.json
          
        echo "‚úÖ Current task definition downloaded"
        
    - name: Update task definition with new image
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: ${{ env.CONTAINER_NAME }}
        image: ${{ needs.build-and-push.outputs.image-uri }}
        environment-variables: |
          ENVIRONMENT=production
          LOG_LEVEL=INFO
          AWS_REGION=${{ env.AWS_REGION }}
          
    - name: Deploy to Amazon ECS service
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true
        
    - name: Wait for deployment to stabilize
      run: |
        echo "‚è≥ Waiting for service to reach steady state..."
        aws ecs wait services-stable \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }}
        echo "‚úÖ Service deployment completed successfully"
        
    - name: Get service details
      run: |
        # Get the load balancer URL
        LOAD_BALANCER_DNS=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].loadBalancers[0].targetGroupArn' \
          --output text | xargs -I {} aws elbv2 describe-target-groups \
          --target-group-arns {} \
          --query 'TargetGroups[0].LoadBalancerArns[0]' \
          --output text | xargs -I {} aws elbv2 describe-load-balancers \
          --load-balancer-arns {} \
          --query 'LoadBalancers[0].DNSName' \
          --output text)
          
        echo "üåê Application URL: https://$LOAD_BALANCER_DNS"
        echo "üì¶ Deployed Image: ${{ needs.build-and-push.outputs.image-uri }}"
        echo "üè∑Ô∏è Image Tag: ${{ needs.build-and-push.outputs.image-tag }}"
        
    - name: Run health checks
      run: |
        echo "üîç Running post-deployment health checks..."
        
        # Wait for application to be ready
        sleep 60
        
        # Health check endpoint
        HEALTH_URL="https://api.theobroma.digital/health"
        echo "Testing health endpoint: $HEALTH_URL"
        
        # Retry health check up to 10 times
        for i in {1..10}; do
          if curl -f -s "$HEALTH_URL" > /dev/null; then
            echo "‚úÖ Health check passed (attempt $i)"
            break
          else
            echo "‚è≥ Health check failed (attempt $i), retrying in 30s..."
            if [ $i -eq 10 ]; then
              echo "‚ùå Health check failed after 10 attempts"
              exit 1
            fi
            sleep 30
          fi
        done
        
    - name: Run smoke tests
      run: |
        echo "üß™ Running production smoke tests..."
        
        BASE_URL="https://api.theobroma.digital"
        
        # Test critical endpoints
        endpoints=(
          "/health"
          "/farms"
          "/docs"
        )
        
        for endpoint in "${endpoints[@]}"; do
          echo "Testing $BASE_URL$endpoint"
          if curl -f -s "$BASE_URL$endpoint" > /dev/null; then
            echo "‚úÖ $endpoint: PASSED"
          else
            echo "‚ùå $endpoint: FAILED"
            exit 1
          fi
        done
        
        echo "‚úÖ All smoke tests passed"
        
    - name: Update deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "## üöÄ Production Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üåê Production URL**: https://api.theobroma.digital" >> $GITHUB_STEP_SUMMARY
          echo "**üì¶ Image**: ${{ needs.build-and-push.outputs.image-uri }}" >> $GITHUB_STEP_SUMMARY
          echo "**üè∑Ô∏è Tag**: ${{ needs.build-and-push.outputs.image-tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**üïí Deployed**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ Health Checks" >> $GITHUB_STEP_SUMMARY
          echo "- Health endpoint: PASSED" >> $GITHUB_STEP_SUMMARY
          echo "- Smoke tests: PASSED" >> $GITHUB_STEP_SUMMARY
          echo "- Service stability: PASSED" >> $GITHUB_STEP_SUMMARY
        else
          echo "## ‚ùå Production Deployment Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**üì¶ Image**: ${{ needs.build-and-push.outputs.image-uri }}" >> $GITHUB_STEP_SUMMARY
          echo "**üïí Failed at**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Please check the deployment logs and fix any issues before retrying." >> $GITHUB_STEP_SUMMARY
        fi

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-production]
    if: failure() && needs.deploy-production.result == 'failure'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Rollback to previous version
      run: |
        echo "üîÑ Initiating rollback to previous stable version..."
        
        # Get the previous task definition revision
        CURRENT_REVISION=$(aws ecs describe-services \
          --cluster ${{ env.ECS_CLUSTER }} \
          --services ${{ env.ECS_SERVICE }} \
          --query 'services[0].taskDefinition' \
          --output text | grep -o '[0-9]*$')
          
        PREVIOUS_REVISION=$((CURRENT_REVISION - 1))
        
        if [ $PREVIOUS_REVISION -gt 0 ]; then
          echo "Rolling back from revision $CURRENT_REVISION to $PREVIOUS_REVISION"
          
          # Update service with previous task definition
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ env.ECS_TASK_DEFINITION }}:$PREVIOUS_REVISION
            
          # Wait for rollback to complete
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }}
            
          echo "‚úÖ Rollback completed successfully"
        else
          echo "‚ùå No previous revision found for rollback"
          exit 1
        fi
